<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>State Channel Demo</title> 
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
        crossorigin="anonymous">
    </script>

    <script src="/scripts/main.js"></script>

    <link rel="stylesheet" href="/styles/sample-loader.css">
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/0.7.4/tailwind.min.css">
    <style>
            .w-96{
                width: 24rem;
            }
            .h-160{
                height: 40rem;
            }
            .hide-me {
                display: none;
            }

            .btn {
                border: 2px solid black;
                border-radius: 3px;
                margin: 10px;
                padding: 5px;
                color: red;
            }
    </style>
</head>
  <body  class="text-pink-darkest bg-teal-lightest relative font-sans">

    {{>home}}
    {{>loader}}
    
    <div id="sc-wrapper">
        {{>open}}
        {{>buy}}
        {{>credits}}
        {{>history}}
    </div>

    <script>

        const showInfo = true;

        function log() {
            if (showInfo) {
                for (let arg in arguments) {
                    console.log(arguments[arg]);
                }
            }
        }
        
        log(aeWeb);

        let initiatorKeyPair = {
            publicKey: '',
            secretKey: ''
        }

        const ONE_AE = 1000000000000000000;

        const url = aeWeb.config.node.API_URL;
        const internalUrl = aeWeb.config.node.INTERNAL_API_URL; 
        const networkId = aeWeb.config.node.NETWORK_ID;

        let responderId = aeWeb.config.responderAddress;

        let Crypto = aeWeb.crypto;
        let Channel = aeWeb.channel;
        let Universal = aeWeb.universal;
        let Wallet = aeWeb.wallet;
        let MemoryAccount = aeWeb.memoryAccount;
        let TxBuilder = aeWeb.txBuilder;

        let initiatorAddress = initiatorKeyPair.publicKey;
        let account;
        let channel;

        let channelReserve;

        let createAccount;
        let updateState;
        let getAndUpdateOffChainBalance;
        let getOffChainBalance;
        let reDeposit;

        let publicAddress;
        let startStateChannel;

        let scWrapper;
        let channelStatus;
        let loadOpenFrame;
        let isChannelOpen;
        let changeFrame;

        let isNextCoffeeFreeOldState = false;
        let isCoffeeFree = false;

        function isNextCoffeeFree() {
            return isCoffeeFree;
        };

        let frames = {
            OPEN: '#open-wrapper',
            BUY: '#buy-wrapper',
            CREDITS: '#credits-wrapper',
            HISTORY: '#history-wrapper',
            LOADER: '#loader-wrapper'
        };


        class Helper {
            constructor(){
                this.updateOffChainBalanceFuncs = {};
                this.onFrameChange = {};
            }

            setUpdateOffChainBalance(frameName, func) {
                this.updateOffChainBalanceFuncs[frameName.toLocaleLowerCase()] = func;
            }

            runUpdateOffChainBalance(frameName) {
                if(this.updateOffChainBalanceFuncs[frameName.toLocaleLowerCase()]){
                    this.updateOffChainBalanceFuncs[frameName.toLocaleLowerCase()]();
                }
            }

            setOnFrameChangeFuncs(frameName, func) {
                if(!this.onFrameChange[frameName]){
                    this.onFrameChange[frameName] = [];
                }

                this.onFrameChange[frameName].push(func)
            }

            runOnFrameChange(frameName) {
                if(this.onFrameChange[frameName]){
                    log('[ON]', frameName);

                    for(let func in this.onFrameChange[frameName]){
                        this.onFrameChange[frameName][func]();
                    }
                }
            }
        }

        const helper = new Helper();

        changeFrame = function () {
            let action = $(this).attr('id').replace('btn-', '').toUpperCase();

            log('[BTN-ACTION]', action);

            scWrapper.hide();
            $(frames[action]).show();
            helper.runUpdateOffChainBalance(frames[action]);
            helper.runOnFrameChange(frames[action]);
        };

        function showLoader(){
            scWrapper.hide();
            $(frames.LOADER).show();
        }

        (async function () {

           // account = await aeWeb.aepp();

            async function createAccountt() {
                const API_URL = 'http://localhost:3001';
                const INTERNAL_API_URL = 'http://localhost:3113';
                const NETWORK_ID = 'ae_devnet';
                const compilerURL = 'https://compiler.aepps.com';

                const keyPair = {
                    publicKey: 'ak_fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk',
                    secretKey: '7c6e602a94f30e4ea7edabe4376314f69ba7eaa2f355ecedb339df847b6f0d80575f81ffb0a297b7725dc671da0b1769b1fc5cbe45385c7b5ad1fc2eaf1d609d'
                }

                return Universal({
                    networkId: NETWORK_ID,
                    url: API_URL,
                    internalUrl: INTERNAL_API_URL,
                    keypair: keyPair,
                    compilerUrl: compilerURL
                });
            }

            account = await createAccountt();

            publicAddress = await account.address();
            
            initiatorAddress = publicAddress;

            log(`[INFO] initiator Address: ${initiatorAddress}`);

            let result = await $.ajax({
                    type: "GET",
                    url: `/faucet?pubKey=${initiatorAddress}`
            });

            log('[RESULT]', result.message);

            $('.change-frame').click(changeFrame);
            
        })();

        (async function () {

            const history = [];

            function clearHistory(){
                isNextCoffeeFreeOldState = false;
                isCoffeeFree = false;

                // clear history array
                while (history.pop());
            }

            scWrapper = $('.all-frames');
            window.scWrapper = scWrapper;

            function loadOpenFrame () {
                scWrapper.hide();
                $(frames.OPEN).show();
            }

            function loadBuyFrame () {
                scWrapper.hide();
                $(frames.BUY).show();
                helper.runUpdateOffChainBalance(frames.BUY);
            }

            function loadCreditFrame() {
                scWrapper.hide();
                $(frames.CREDITS).show();
                helper.runUpdateOffChainBalance(frames.CREDITS);
            } 

            loadOpenFrame();
            
            isChannelOpen = function () {
                if(channelStatus !== 'open') {
                    loadOpenFrame();

                    clearHistory();

                    return false;
                }

                return true;
            }

            /* Open state channel*/
            let btnsStartStateChannel = $('.btns-start-sc');
            btnsStartStateChannel.click(startStateChannel);

            startStateChannel = async function () {

                //runTest(account);
                //console.log('wait for test run...');
                //return;

                let depositValue = parseInt($(this).data('amount-value'));

                log('[DEBUG] open SC | deposit value:', depositValue);

                depositAmount = depositValue * ONE_AE;
                
                showLoader();

                if (!depositAmount || depositAmount < 1) {
                    alert('Invalid deposit amount!');
                    return;
                }

                $('.start-wrapper').hide();

                let params = await getParams();

                if (depositAmount < params.responderAmount) {
                    alert(`Deposit should be equal or greater than ${params.responderAmount}!`);
                    $('.start-wrapper').show();    
                    hideLoader();
                    return;
                }

                params.responderAmount = parseInt(depositAmount);
                params.initiatorAmount = parseInt(depositAmount);
                params.initiatorId = initiatorAddress;

                channelReserve = parseInt(params.channelReserve);


                channel = await connectAsInitiator(params, sign);
                channelActions(channel);

                responderId = params.responderId;

                let data = {
                    params: params
                }

                $.ajax({
                    type: "POST",
                    url: '/channel',
                    data: data,
                    success: function (response) {
                        log('[RESULT] channel creation response: ', response);
                    }
                });
            }

            async function connectAsInitiator(params, sign) {

                const TIMEOUT = 1000 * 60 * 20;

                const _params = {
                    ...params,
                    url: aeWeb.config.node.STATE_CHANNEL_URL,
                    role: 'initiator',
                    sign: sign,
                    //timeout_accept : TIMEOUT,
                    //timeout_funding_lock : TIMEOUT,
                    //timeout_awaiting_locked : TIMEOUT,
                    //timer_funding_lock: TIMEOUT,
                    //timeout_idle: TIMEOUT,
                    //timeout_funding_create: TIMEOUT,
                    //timeout_sign: TIMEOUT,
                    
                    //timeout_awaiting_open: TIMEOUT,
                    timeout_idle: TIMEOUT,
                    minimum_depth: 0
                }

                _params.url = 'localhost:3001';

                //log('[PARAMS]', _params);

                //return await Channel(_params);

                return await Channel({
                    url: 'ws://localhost:3001',
                    pushAmount: 3,
                    initiatorAmount: 1000000000000000,
                    responderAmount: 1000000000000000,
                    channelReserve: 20000000000,
                    ttl: 10000,
                    host: 'localhost',
                    port: 3001,
                    lockPeriod: 1,
                    minimum_depth: 0,
                    initiatorId: initiatorAddress,  // 'ak_2fsZ9H3veZedfaCgX3GZpWvfxx1Z5T4n4dQXVhYKEdu8SwEX6q',
                    responderId: 'ak_2mwRmUeYmfuW93ti9HMSUJzCk1EYcQEfikVSzgo6k2VghsWhgU',
                    role: 'initiator',
                    sign: (tag, tx) => {
                        console.log('initiator sign', tag);
                        console.log(tx);
                        console.log();
                        return account.signTransaction(tx)
                    }
                })
            }

            async function sign(tag, tx) {
                // Deserialize binary transaction so we can inspect it
                const txData = deserializeTx(tx);
                
                if (txData.tag === 'CHANNEL_CREATE_TX') {
                    log('[SIGN] CHANNEL_CREATE_TX', txData);
                    
                    return account.signTransaction(tx);
                }

                if (tag === 'update_ack' || tag === 'CHANNEL_OFFCHAIN_TX') {
                    
                    log('[SIGN] CHANNEL_OFFCHAIN_TX', txData);
                    
                    return account.signTransaction(tx);
                }

                if (tag === 'shutdown_sign_ack' || txData.tag === 'CHANNEL_CLOSE_MUTUAL_TX') {
                    log('[SIGN] CHANNEL_CLOSE_MUTUAL_TX', txData);
                    
                    return account.signTransaction(tx);
                }

                console.log('[ERROR] Not a suitable case to sign a TX', txData);
            }

            async function channelActions(channel) {

                channel.on('statusChanged', (status) => {
                    channelStatus = status;
                    log(`[STATUS] ${status.toUpperCase()}`);

                    if(status.toUpperCase() === 'DISCONNECTED') {
                        loadOpenFrame();
                    }
                });

                channel.on('onChainTx', (tx) => {
                    log('[ON-CHAIN-TX]', tx);
                })

                channel.on('message', async (msg) => {

                    console.log('[MESSAGE]', msg);

                    let info = JSON.parse(msg.info);

                    if (msg.info.indexOf('successfully created') >= 0) {
                        loadBuyFrame();

                        log(`[ON_MESSAGE] ${msg.info}`);

                        //showSeconds(180);
                        function showSeconds (maxSeconds) {
                            let currentSecond = 1;
                            let interval = setInterval(function () {
                                console.log(currentSecond++);
                                if(currentSecond >= maxSeconds) {
                                    clearInterval(interval);
                                }
                            }, 1000);
                        }
                        
                    }

                    if(msg.info.indexOf('[OFF_CHAIN]') >= 0) {
                        log(`[ON_MESSAGE] ${msg.info}`);

                        let historyData = {
                            quantity: 1,
                            name: info.name,
                            amount: info.amount,
                            date: new Date()
                        };

                        let oldState = isNextCoffeeFreeOldState;
                        isCoffeeFree = info.isNextFree;

                        if (isNextCoffeeFree || oldState){
                            // maybe more correct would be onEvent || or throw events and event listener to execute proper function
                            helper.runOnFrameChange(frames.BUY);
                        }

                        history.push(historyData);
                    }
                });
            }

            getAndUpdateOffChainBalance = async function () {
                let balance = await getOffChainBalance();
                updateOffChainBalance(balance);
            }
            
            getOffChainBalance = async function () {
                // off chain balances
                let balances = await channel.balances([ initiatorAddress ]);
                let offChainBalance = balances[ initiatorAddress ];

                return offChainBalance;
            }

            updateState = async function (channel, senderAddress, recipientAddress, amount) {

                log(`[DEBUG] sender: ${senderAddress}, recipient: ${recipientAddress}, amount: ${amount}`);

                try {
                    let result = await channel.update(
                        // Sender account
                        senderAddress,
                        // Recipient account
                        recipientAddress,
                        // Amount
                        parseInt(amount),
                        // This function should verify offchain transaction
                        // and sign it with initiator's private key
                        async (tx) => await account.signTransaction(tx)
                    );
                } catch (e) {
                    alert('[ERROR] UPDATE: Something went wrong! Invalid Tx!');
                    console.log(e);
                }
            }

            reDeposit = async function (amount) {

                log('[DEBUG] try to redeposit with:', amount);
                
                showLoader();
                let result = await channel.deposit(parseInt(amount), async (tx) => await account.signTransaction(tx));
                
                loadCreditFrame()

                if(result.accepted){
                    let historyData = {
                        quantity: 1,
                        name: 'CREDIT',
                        amount: amount,
                        date: new Date()
                    };

                    history.push(historyData);
                }

                log('[RESULT] credit', result);
            }

            /* Shutdown state channel*/
            closeChannel = async function () {

                if(!isChannelOpen()) {
                    console.log('[ERROR] State Channel is DISCONNECTED!');
                    return;
                }

                try {
                    
                    let shutDownResult = await channel.shutdown(async (tx) => {
                        clearHistory();
                        return account.signTransaction(tx);
                    });

                    log('[RESULT] shutdown', shutDownResult);
                } catch (e) {
                    console.log('[ERROR] Error occurred while closing the channel.')
                    console.log(e);
                }

                let data = {
                    initiatorAddress: initiatorAddress
                }

                $.ajax({
                    type: "POST",
                    url: '/stop',
                    data: data,
                    success: function (response) {
                        log('[INFO] state channel successfully closed:', response)
                    },
                    error: function (response) {
                        console.log('[ERROR] stop:', response)
                    }
                });
            }

            credit = async function () {

                if(!isChannelOpen()){
                    return;
                }

                let amountToRedeposit = $(this).data('credit');
                
                if (isNaN(amountToRedeposit) || amountToRedeposit <= 0) {
                    alert("Redeposit should be a number and greater than 0(zero).");
                    return;
                }

                amountToRedeposit = parseInt(amountToRedeposit);

                log('[DEBUG] parse credit:', amountToRedeposit);

                await reDeposit(amountToRedeposit * ONE_AE);
            }

            getHistory = function () {
                return history;
            }

            /* Utils */
            createAccount = async function (keyPair) {
                let account = await Universal({
                    networkId: networkId,
                    url: url,
                    internalUrl: internalUrl,
                    keypair: {
                        publicKey: keyPair.publicKey,
                        secretKey: keyPair.secretKey
                    },
                    //compilerUrl: 'localhost:10101' 
                    compilerUrl: 'https://compiler.aepps.com'
                })

                return account;
            }

            async function getParams() {
                let result = await $.ajax({
                    type: "GET",
                    url: '/config/params'
                });
                
                return result;
            }

            function deserializeTx(tx) {
                const txData = Crypto.deserialize(Crypto.decodeTx(tx), { prettyTags: true });

                return txData;
            }

            async function runTest(initiator) {

                const compilerURL = 'localhost:10101' // https://compiler.aepps.com'
                
                const initiatorKeyPair = {
                    publicKey: 'ak_2mwRmUeYmfuW93ti9HMSUJzCk1EYcQEfikVSzgo6k2VghsWhgU',
                    secretKey: 'bb9f0b01c8c9553cfbaf7ef81a50f977b1326801ebf7294d1c2cbccdedf27476e9bbf604e611b5460a3b3999e9771b6f60417d73ce7c5519e12f7e127a1225ca'
                }
                
            
                //let initiator
                let initiatorCh
                
                const initiatorSign = (tag, tx) => {
                    console.log('initiator sign', tag);
                    console.log(tx);
                    console.log();
                    return initiator.signTransaction(tx)
                }
                
                const sharedParams = {
                    url: 'ws://localhost:3001',
                    pushAmount: 3,
                    initiatorAmount: 1000000000000000,
                    responderAmount: 1000000000000000,
                    channelReserve: 20000000000,
                    ttl: 10000,
                    host: 'localhost',
                    port: 3001,
                    lockPeriod: 1,
                    minimum_depth: 0,
                    // timeout_idle: 1000 * 60 * 20
                }
            
                sharedParams.initiatorId = await initiator.address()
            
                //await initiator.spend('6000000000000000', await responder.address())
                
                //console.log('[SHARED PARAMS]');
                //console.log({
                //    ...sharedParams,
                //    role: 'initiator',
                //   sign: initiatorSign
                //});
                //console.log();
            
                initiatorCh = await Channel({
                    ...sharedParams,
                    role: 'initiator',
                    sign: initiatorSign
                })
                
                let result = await $.ajax({
                    type: "GET",
                    url: '/test'
                });
            
                initiatorCh.on('statusChanged', (status) => {
                    console.log(`[${status.toUpperCase()}]`);
                    console.log();
                })
            
                const amount = 10
                result = await initiatorCh.update(
                await initiator.address(),
                'ak_fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk',
                amount,
                //initiatorSign
                async (tx) => initiator.signTransaction(tx)
                );
            
                console.log('[UPDATE]', result);
            }

        })();
    </script>

</body>
</html>